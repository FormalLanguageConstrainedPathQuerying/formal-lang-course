# Задача 12. Экспериментальное исследование алгоритмов решения задачи достижимости с КС ограничениями

* **Мягкий дедлайн**: 01.12.2021, 23:59
* **Жёсткий дедлайн**: 08.12.2021, 23:59
* Полный балл: 15

## Задача

Задача посвящена анализу производительности различных алгоритмов решения задачи достижимости с контекстно-свободными ограничениями: алгоритма Хеллингса, матричного алгоритма, тензорного алгоритма. В ходе анализа необходимо
- Сравнить производительности реализаций различных алгоритмов для одной аппаратной платформы (CPU, GPU) и определить наиболее производительный алгоритм в рамках одной платформы.
- Сравнить производительности различных реализаций алгоритмов для разных платформ (CPU vs. GPU) и определить наиболее производительную реализацию.
- Сравнить производительности CFPQ алгоритмов со специализированными RPQ алгоритмами в задаче RPQ анализа и определить необходимость существования решения для частных случаев.

Решение данной задачи оформляется как Python notebook на [Google colab](https://colab.research.google.com/). Для того, чтобы обеспечить возможность проверки, решение делается доступным по ссылке (с правами на комментирование), ссылка добавляется в readme репозитория, в котором выполняются остальные задачи, делается реквест с этим изменением.

Решением является не просто код, но отчёт об экспериментальном исследовании, который должен являться связанным текстом и содержать (как минимум) следующие разделы:
- Постановка задачи
- Выбор и описание исследуемых решений
- Описание набора данных для экспериментов
  - Графы
  - Запросы
- Описание эксперимента
  - Оборудование
  - Что и как замерялось (количество экспериментов, точность замеров, единицы измерения)
- Результаты экспериментов
  - Графики, таблицы
- Анализ результатов экспериментов
  - Какой алгоритм и в каких случаях лучше? Почему?

В задачах ниже лучше сразу предусмотреть общий интерфейс функций, реализующих алгоритмы, чтобы было проще ставить эксперименты. Обратите внимание, что в запросах будет использоваться обозначение для прохода по ребру в обратном направлении: если есть ребро 1 -[a]-> 2, то терминал **a_r** в грамматике обозначает, что по такому ребру надо идти из 2 в 1. При этом обратные рёбра в графе в явном виде отсутствуют. Однако её легко решить транспонировав матрицу смежности для соответствующего терминала.

- [ ] Используя [pyCuBool](https://pypi.org/project/pycubool/) реализовать матричный алгоритм решения задачи достижимости с КС ограничениями. Аналогично тому, как это было сделано в домашней работе 10.
- [ ] Используя [pyCuBool](https://pypi.org/project/pycubool/) реализовать тензорный алгоритм решения задачи достижимости с КС ограничениями. Аналогично тому, как это было сделано в домашней работе 11.
- [ ] Подключить реализацию алгоритма Хеллингса из работы 9, матричного из 10 и тензорного из 11.
- [ ] Сформировать набор данных.
  - [ ] Выбрать все графы из раздела [RDF](https://jetbrains-research.github.io/CFPQ_Data/dataset/RDF.html).
  - [ ] Запросы к RDF состоят из следующих блоков
    - Запросы из работы 5. Так как регулярные языки --- это подмножество контекстно-свободных, то решения, рассматриваемые в данной работе должны справляться с ними. Взять необходимо ровно те запросы, которые использовали именно вы. При этом, обратите внимание на то, что для разных алгоритмов нужен разный формат входа. Например, для тензорного грамматику из регулярного выражения можно получить просто сделав это выражение правой частью единственного правила.
    - Три классических запроса для анализа иерархии.
      - ```S -> subClassOf_r S subClassOf | type_r S type | subClassOf_r subClassOf | type_r type ```
      - ```S -> subClassOf_r S subClassOf | subClassOf ```
      - ```S -> broaderTransitive S broaderTransitive_r | broaderTransitive broaderTransitive_r ```
  - [ ] Выбрать графы bzip, gzip, ls, init, drivers, arch. Это графы, построенные по реальным программам и предназначенные для решения задач статического анализа.
  - [ ] Для статического анализа использовать единственный запрос. Обратите внимание, что он записан в максимально общем виде и непосредственно грамматика будет зависеть от алгоритма, который будет исследоваться.
    - ```
       M -> d_r V d
       V -> (M? a_r)∗ M? (a M?)∗
      ```
- [ ] С использованием сформированного набора данных провести сравнение производительности следующих решений
  - алгоритм Хеллингса
  - матричный алгоритм, реализованный с использованием sciPy
  - тензорный алгоритм, реализованный с использованием sciPy
  - матричный алгоритм, реализованный с использованием pyCuBool
  - тензорный алгоритм, реализованный с использованием pyCuBool
  - алгоритм выполнения регулярных запросов, реализованный с использованием pyCuBool (работа 5). Здесь только для RDF и регулярных запросов.
  - алгоритм выполнения регулярных запросов, реализованный с использованием sciPy. Здесь только для RDF и регулярных запросов.
- [ ] Оформить результаты экспериментов
- [ ] Провести анализ результатов
- [ ] Сделать notebook доступным по ссылке (обязательно выдать права на комментирование проверяющему)
